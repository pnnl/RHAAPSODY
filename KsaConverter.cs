using System;
using System.Runtime.InteropServices;
using System.IO;

using BitMiracle.LibTiff.Classic;

/* Disclaimer

This material was prepared as an account of work sponsored by an agency of the United States Government.  
Neither the United States Government nor the United States Department of Energy, nor Battelle, 
nor any of their employees, nor any jurisdiction or organization that has cooperated in the development 
of these materials, makes any warranty, express or implied, or assumes any legal liability or responsibility 
for the accuracy, completeness, or usefulness or any information, apparatus, product, software, 
or process disclosed, or represents that its use would not infringe privately owned rights.

Reference herein to any specific commercial product, process, or service by trade name, trademark, manufacturer, 
or otherwise does not necessarily constitute or imply its endorsement, recommendation, 
or favoring by the United States Government or any agency thereof, or Battelle Memorial Institute. 
The views and opinions of authors expressed herein do not necessarily state or reflect those of 
the United States Government or any agency thereof.

PACIFIC NORTHWEST NATIONAL LABORATORY
operated by
BATTELLE
for the
UNITED STATES DEPARTMENT OF ENERGY
under Contract DE-AC05-76RL01830

*/

/******************************* read me ************************************************************
 This class converts a raw .ksah generated by kSA 400, version 5.90, to a scaled 16bit grayscale .tif file.
 It is tested only in this particular circumstance.

 Dependencies:

    .NET Framework 4.5
    BitMiracle.LibTiff.Classic

 Usage:

    KsaConverter converter = new KsaConverter();

    string infile = "c:\\inny.ksah";
    converter.ReadFile(infile);

    string outfile = "c:\\outty.tif";
    converter.WriteTiff(outfile);

 ****************************************************************************************************/

namespace SurfoDevices
{
    /// <summary>
    /// typed and ordered structure mapping the binary header of a kSA file
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct KsaHeader
    {
        /// <summary>
        /// size of header in bytes
        /// </summary>
    	public ushort headerSize;
        /// <summary>
        /// always 1 - Fixed header
        /// </summary>
        public byte headerType;
        /// <summary>
        /// 1 - Raw    2 â€“ scanmode (no scanInfo)
        /// </summary>
        public byte imageType;
        /// <summary>
        /// 1 for now (may support movies later)
        /// </summary>
        public uint numberOfImages;
        /// <summary>
        /// always 1 - Mono for now (color later)
        /// </summary>
        public byte imageFormat;
        /// <summary>
        /// 4 bytes
        /// </summary>
        public float exposureTimeSeconds; 
        /// <summary>
        /// bits per pixel
        /// </summary>
        public byte bitsPerPixel; 
        /// <summary>
        /// max image size 65535 x 65535
        /// </summary>
        public ushort imageWidth; 
        /// <summary>
        /// max image size 65535 x 65535
        /// </summary>
        public ushort imageHeight;
    }

    /// <summary>
    /// Class to convert a kSA proprietary image file to greyscale TIF
    /// </summary>
    public class KsaConverter
    {
        /// <summary>
        /// typed and ordered structure mapping the binary header of a kSA file
        /// </summary>
        public KsaHeader header { get; set; }
        /// <summary>
        /// byte array containing image data
        /// </summary>
        public byte[] data { get; set; }

        /// <summary>
        /// maximum data value for normalization
        /// </summary>
        public ushort max;
        /// <summary>
        /// minimum data value for normalization
        /// </summary>
        public ushort min;

        /// <summary>
        /// loads the class from a previously opened filestream
        /// </summary>
        /// <param name="stream">previously opened filestream</param>
        public void ReadFile(Stream stream)
        {
            int count = Marshal.SizeOf(typeof(KsaHeader));

            //byte[] readBuffer = new byte[count];
            BinaryReader reader = new BinaryReader(stream);
            byte[] readBuffer = reader.ReadBytes(count);

            // KSA fields are little-endian, reverse them for windows
            Array.Reverse(readBuffer, 0, 2);
            Array.Reverse(readBuffer, 4, 4);
            Array.Reverse(readBuffer, 14, 2);
            Array.Reverse(readBuffer, 16, 2);

            // fill the header structure with the modified readBuffer
            GCHandle handle = GCHandle.Alloc(readBuffer, GCHandleType.Pinned);
            header = (KsaHeader)Marshal.PtrToStructure(handle.AddrOfPinnedObject(), typeof(KsaHeader));
            handle.Free();

            // 16 vs 32 bit
            int bytespp = 1;
            if (header.bitsPerPixel > 23)
                bytespp = 4;
            else if (header.bitsPerPixel > 8)
                bytespp = 2;

            // count in bytes
            count = header.imageWidth * header.imageHeight * bytespp;

            // fill data buffer
            data = reader.ReadBytes(count);

            // total pixels
            int pixels = header.imageWidth * header.imageHeight;

            // initialize min and max to bounds
            min = (ushort)(Math.Pow(2, 16) - 1);
            max = 0;

            // calculate min/max
            for (int i = 0; i < pixels; i++)
            {
                // increment by bytes per pixel
                int dataIndex = i * bytespp;

                ushort value = (ushort) BitConverter.ToInt16(data, dataIndex);

                if (value > max) max = value;
                if (value < min) min = value;
            }
        }

        /// <summary>
        /// loads the class with the .ksah file located at path
        /// </summary>
        /// <param name="path">filepath to read</param>
        public void ReadFile(string path)
        {
            StreamReader stream = new StreamReader(path);

            ReadFile(stream.BaseStream);

            stream.Close();
        }

        /// <summary>
        /// reverse byte order (16-bit)
        /// </summary>
        /// <param name="value">value to reverse</param>
        /// <returns></returns>
        public UInt16 ReverseBytes(UInt16 value)
        {
            return (UInt16)((value & 0xFFU) << 8 | (value & 0xFF00U) >> 8);
        }

        /// <summary>
        /// writes the contents of the class as a tif file
        /// </summary>
        /// <param name="fileName">file to create</param>
        public void WriteTiff(string fileName)
        {
            int width = header.imageWidth;
            int height = header.imageHeight;

            using (Tiff output = Tiff.Open(fileName, "w"))
            {
                output.SetField(TiffTag.IMAGEWIDTH, width);
                output.SetField(TiffTag.IMAGELENGTH, height);
                output.SetField(TiffTag.SAMPLESPERPIXEL, 1);
                output.SetField(TiffTag.BITSPERSAMPLE, 16);
                output.SetField(TiffTag.ORIENTATION, BitMiracle.LibTiff.Classic.Orientation.TOPLEFT);
                output.SetField(TiffTag.ROWSPERSTRIP, height);
                output.SetField(TiffTag.PLANARCONFIG, PlanarConfig.CONTIG);
                output.SetField(TiffTag.PHOTOMETRIC, Photometric.MINISBLACK);
                output.SetField(TiffTag.COMPRESSION, Compression.NONE);
                output.SetField(TiffTag.FILLORDER, FillOrder.MSB2LSB);

                int stride = header.imageWidth * sizeof(short);

                byte[] buffer = new byte[stride];
                ushort[] shorts = new ushort[header.imageWidth];

                // output normalized data
                for (int i = 0; i < height; i++)
                {
                    int offset = stride * i;
                    
                    Buffer.BlockCopy(data, offset, shorts, 0, buffer.Length);

                    // normalize range
                    double range = (max - min);

                    // normalize line
                    for (int j = 0; j < header.imageWidth; j++)
                    {
                        double val = shorts[j];
                        double fraction = (val - min) / range;

                        shorts[j] = (ushort)(fraction * (Math.Pow(2, 16) - 1));
                    }

                    Buffer.BlockCopy(shorts, 0, buffer, 0, buffer.Length);

                    output.WriteScanline(buffer, i);
                }
            }
        }
    }
}
